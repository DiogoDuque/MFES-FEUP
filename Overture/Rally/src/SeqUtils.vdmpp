class Sequence
	
functions 

	static public Sum[@T]: seq of @T ->  @T
		Sum(s) == SumAux[@T](s)(0)
		pre
			is_(s, seq of real);

	static SumAux[@T] : seq of @T -> @T -> @T
		SumAux(s)(sum) ==
		  if is_(s,seq of real) and is_real(sum)
		  then
			if s = [] then
				sum
			else
				SumAux[@T](tl s)(sum + hd s)
		  else undefined;

	static length_measure[@T] : seq of @T +> nat
		length_measure(s) == len s;

	static public GetAverage[@T]: seq of @T ->  [real]
		GetAverage(s) == if s = [] then nil else GetAverageAux[@T](s)(0)(len s);

	static GetAverageAux[@T] : seq of @T -> @T -> @T -> real
		GetAverageAux(s)(sum)(numberOfElem) ==
		 if is_(s,seq of real) and is_real(sum) and is_real(numberOfElem)
		 then
			cases s :
			[h] ^ tail	-> GetAverageAux[@T](tail)(sum + h)(numberOfElem),
			[]			-> sum / numberOfElem
			end
		else undefined;

	static public isAscendingTotalOrder [@T]: (@T * @T -> bool) -> seq of @T -> bool
		isAscendingTotalOrder (decideOrderFunc)(s) ==
			forall i,j  in set inds s & i < j  => decideOrderFunc(s(i),s(j)) or s(i) = s(j);

	static public isDescendingTotalOrder [@T]: (@T * @T -> bool) -> seq of @T -> bool
		isDescendingTotalOrder (decideOrderFunc)(s) ==
			forall i,j  in set inds s & i < j  => decideOrderFunc(s(j),s(i)) or s(i) = s(j);

	static public isAscendingOrder [@T]: seq of @T -> bool
		isAscendingOrder(s) ==
			isAscendingTotalOrder [@T](lambda x : @T, y : @T & if is_real(x) and is_real(y)
		                                                     then x < y
		                                                     else undefined)(s);

	static public isDescendingOrder[@T]: seq of @T -> bool
		isDescendingOrder(s) ==
			isDescendingTotalOrder [@T](lambda x : @T, y : @T & if is_real(x) and is_real(y)
		                                                      then x < y
		                                                      else undefined)(s);

	static public sort[@T] : (@T * @T -> bool) -> seq of @T -> seq of @T
		sort(decideOrderFunc)(s) ==
			cases s:
				[]	-> [],
				[h]^tail	-> 
					sort[@T](decideOrderFunc)([tail(i) | i in set inds tail & decideOrderFunc(tail(i),h)]) ^
					[h] ^
					sort[@T](decideOrderFunc)([tail(i) | i in set inds tail & not decideOrderFunc(tail(i),h)])
			end;

	static public ascendingOrderSort[@T] : seq of @T -> seq of @T
		ascendingOrderSort(s) == sort[@T](lambda x : @T, y : @T & if is_real(x) and is_real(y)
		                                                          then x < y
	                                                          else undefined)(s);

	static public descendingOrderSort[@T] : seq of @T -> seq of @T
		descendingOrderSort(s) == sort[@T](lambda x : @T, y : @T & if is_real(x) and is_real(y)
		                                                           then x > y
		                                                           else undefined)(s);

	static public isOrdered[@T] : seq of (@T * @T -> bool) -> seq of @T -> seq of @T -> bool
		isOrdered(decideOrderFuncSeq)(s1)(s2) ==
			cases mk_(s1,s2):
				mk_([],[])		-> false,
				mk_([],-)		-> true,
				mk_(-,[])	-> false,
				mk_([h1]^tail1,[h2]^tail2)	->
					if (hd decideOrderFuncSeq)(h1,h2) then
						true
					elseif (hd decideOrderFuncSeq)(h2,h1) then
						false
					else
						Sequence`isOrdered[@T](tl decideOrderFuncSeq)(tail1)(tail2)
			end;

	static public Merge[@T] : (@T * @T -> bool) -> seq of @T -> seq of @T -> seq of @T
		Merge(decideOrderFunc)(s1)(s2) == 
			cases mk_(s1,s2):
				mk_([], y)						-> y,
				mk_(x, [])						-> x,
				mk_([h1]^tail1,[h2]^tail2)		->
					if decideOrderFunc(h1,h2) then
						[h1] ^ Sequence`Merge[@T](decideOrderFunc)(tail1)(s2)
					else
						[h2] ^ Sequence`Merge[@T](decideOrderFunc)(s1)(tail2)
			end;
	
	static public InsertAt[@T]: nat1 -> @T -> seq of @T -> seq of @T
		InsertAt(position)(e)(s) ==
			cases mk_(position, s) :
			mk_(1, str)				-> [e] ^ str,
			mk_(-, [])				-> [e],
			mk_(pos, [h] ^ tail)	-> [h] ^ InsertAt[@T](pos - 1)(e)(tail)
			end;
	
	static public RemoveAt[@T]: nat1 -> seq of @T -> seq of @T
		RemoveAt(position)(s) ==
			cases mk_(position, s) :
			mk_(1, [-] ^ tail)		-> tail,
			mk_(pos, [h] ^ tail)	-> [h] ^ RemoveAt[@T](pos - 1)(tail),
			mk_(-, [])				-> []
			end;
	
	static public UpdateAt[@T]: nat1 -> @T -> seq of @T -> seq of @T
		UpdateAt(position)(e)(s) ==
			cases mk_(position, s) :
			mk_(-, [])				-> [],
			mk_(1, [-] ^ tail)		-> [e] ^ tail,
			mk_(pos,  [h] ^ tail)	-> [h] ^ UpdateAt[@T](pos - 1)(e)(tail)
			end;
	
	static public filter[@T]: (@T -> bool) -> seq of @T -> seq of @T
		filter(f)(s) == [s(i) | i in set inds s & f(s(i))];
	
	static public Index[@T]: @T -> seq of @T -> int
		Index(e)(s) == 
			let	i = 0
			in	IndexAux[@T](e)(s)(i);
	
	static IndexAux[@T]: @T -> seq of @T -> int -> int
		IndexAux(e)(s)(indx) ==
			cases s:
				[]			-> 0,
				[x]^xs	->
					if x = e then 
						indx + 1
					else
						IndexAux[@T](e)(xs)(indx+1)
			end;

end Sequence