class Stage

types
	public StageType = <Timed> | <Transport> | <Special>;
	public Date = DateUtils`Date;
	public StageId = nat1;

instance variables
	public static currentId: nat1 := 1;
	
  private performances: seq of Performance := [];
  private type: StageType;
  private date: Date;
  private distance: real;
  private id: StageId;
  
  -- performances have unique drivers
  inv not exists p1, p2 in seq performances &
  			p1.GetDriver() = p2.GetDriver();
  
operations
  public Stage : StageType * Date * real ==> Stage
		Stage(type0, date0, distance0) == (
			type := type0;
			date := date0;
			distance := distance0;
			id := currentId;
			currentId := currentId + 1;
		  return self;
		)
		pre distance0 > 0
		post type = type0 and date = date0 and distance = distance0 and id = currentId - 1;

	pure public GetType: () ==> StageType
		GetType() ==
		  return type
		post RESULT = type;		
	
	pure public GetId: () ==> StageId
		GetId() ==
		  return id
		post RESULT = id;		
	
	pure public GetDate: () ==> Date
		GetDate() ==
		  return date
		post RESULT = date;
		
	pure public GetDistance: () ==> real
		GetDistance() ==
		  return distance
		post RESULT = distance;
	
	pure public GetPerformances: () ==> seq of Performance
		GetPerformances() ==
			return performances
		post RESULT = performances;
		
	public AddPerformance: Performance ==> ()
		AddPerformance(p) ==
			performances := InsertSorted(p, performances, p.Compare);
		
	public GetDriverPerformance: Driver ==> Performance
		GetDriverPerformance(d) == (
			let i in set inds performances be st performances(i).GetDriver() = d
	    in return performances(i);
		);
		
functions
	private static InsertSorted(i: Performance, l: seq of Performance, 
                  compare: Performance * Performance -> int) res : seq of Performance ==
    cases true :
      (l = [])    -> [i],
      (compare(i, hd l) <= 0)  -> [i] ^ l,
      others      -> [hd l] ^ InsertSorted(i, tl l, compare)
    end;

end Stage
